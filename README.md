# A summary of messages from Telegram

Экспорт сообщений одного пользователя из Telegram‑экспорта: из выбранного чата **или** из всех чатов. Скрипт устойчив к «битым хвостам» JSON, умеет работать с экспортами без `chats.list`, нормализует юникод‑пробелы и корректно собирает текст из смешанных структур (`str` + `[{"type":"link",...}]`).

---

## Возможности

* Фильтр по **user‑id** (`--user-id`) или по **части имени** (`--user`).
* Выбор чата по **названию** (`--chat`, частичное совпадение) или по **числовому ID** (`--chat-id`).
* Если чат не указан, обход **всех чатов** в файле и сбор результатов в общие файлы `*_ALL.txt / *_ALL.csv` с колонкой `chat`.
* Устойчивый потоковый парсер объектов `{...}`: не ломается на «склеенных» экспорт‑файлах и на обрезанном конце.
* Нормализация Unicode: удаление BOM, замену узких пробелов, схлопывание повторов.
* Запись **TXT**‑выписки с блоками ответов и **CSV** с полями для последующего анализа.

---

## Требования

* Python **3.9+**.
* Экспорт Telegram в **JSON** (Settings → Export data → JSON). Поддерживаются:

  * Обычный экспорт с `chats.list`.
  * «Склейка» нескольких чатов подряд (без `chats.list`).

---

## Установка

```bash
# Виртуальное окружение по желанию
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\\Scripts\\activate

# Зависимостей нет, достаточно стандартной библиотеки Python
```

---

## Быстрый старт

1. Скачайте экспорт Telegram в JSON и сохраните файл, например `result.json`.
2. Определите фильтр автора:

   * Если знаете **user‑id**: используйте `--user-id 305696040`.
   * Если нет, используйте `--user "Имя"` (часть имени, без регистра). Опция `--exact` включает точное совпадение имени.
3. Запустите один из сценариев ниже.

---

## Примеры запуска

```bash
# 1) Один чат по id
python tg_self_analyze.py --in result.json --user-id 305696040 --chat-id 1863959277

# 2) Один чат по названию (частичный матч)
python tg_self_analyze.py --in result.json --user "Татьяна" --chat "42 ИП Куратор"

# 3) По всем чатам (чат не задан):
python tg_self_analyze.py --in Kirill.json --user "Михаил"
python tg_self_analyze.py --in Kirill.json --user-id 305696040
```

На Windows PowerShell то же самое:

```powershell
python tg_self_analyze.py --in .\result.json --user "Кирилл"
```

---

## Аргументы командной строки

| Аргумент    | Описание                                                                |
| ----------- | ----------------------------------------------------------------------- |
| `--in`      | Путь к JSON экспорту Telegram. По умолчанию `result.json`.              |
| `--user-id` | Числовой ID пользователя (например `305696040`). Приоритетнее `--user`. |
| `--user`    | Часть имени автора, нечувствительно к регистру.                         |
| `--exact`   | Когда указан `--user`, включает точное совпадение имени.                |
| `--chat`    | Название чата или его часть. Unicode‑нормализация включена.             |
| `--chat-id` | Числовой ID чата из экспорта. Надежнее, чем имя.                        |
| `--txt-out` | Путь для TXT‑вывода. Если не указан, формируется автоматически.         |
| `--csv-out` | Путь для CSV‑вывода. Если не указан, формируется автоматически.         |

Минимально нужен **один** фильтр автора: `--user-id` **или** `--user`.

---

## Формат вывода

### TXT

* Для одного чата: `messages_<user>.txt`.
* Для всех чатов: `messages_<user>_ALL.txt` с секциями `## Чат: ...`.
* Внутри каждого сообщения печатаются дата, автор, `from_id`, `id`, текст.
* Если сообщение было ответом, добавляется блок с цитатой исходного сообщения и метаданными.

### CSV

* Для одного чата: `messages_<user>.csv`.
* Для всех чатов: `messages_<user>_ALL.csv`.
* Колонки CSV:

  * `chat` — имя чата
  * `id` — id сообщения
  * `date` — ISO‑дата
  * `from` — имя автора
  * `from_id` — строковый идентификатор из экспорта (например `user305696040`)
  * `text` — плоский текст сообщения
  * `reply_to_id` — id сообщения, на которое был ответ
  * `reply_from`, `reply_date`, `reply_text` — автор, дата и текст исходного сообщения

---

## Как получить user‑id и chat‑id

* `user‑id` можно взять из поля `from_id` в нужном сообщении (`"user305696040"` → число `305696040`).
* `chat‑id` отображается в списке, который скрипт печатает при старте, либо его можно найти в JSON по ключу `"id"` внутри блока чата. Скрипт сам покажет до 200 найденных чатов с их ID.

---

## Особенности и оговорки

* «Избранное» и аналогичные системные чаты автоматически пропускаются по умолчанию, если чат не задан.
* Текст сообщений собирается из строк и словарей вида `{...}` внутри массива `text` в экспорте Telegram.
* Скрипт устойчив к обрезанным JSON‑файлам: пропускает битые объекты, продолжает парсинг.
* Для больших экспортов возможна высокая нагрузка на память и диск при записи `*_ALL` файлов. Фильтруйте по конкретному чату, если необходимо ускорение.

---

## Типичные ошибки и решения

* **"Укажи --user-id ИЛИ --user"** — не задан фильтр автора. Укажите хотя бы один из них.
* **"Чат по маске не найден" / "Чат с id=... не найден"** — проверьте правильность имени/ID. Скрипт печатает список первых 200 чатов для навигации.
* **Пустые файлы вывода** — для выбранного фильтра автора сообщений не нашлось. Попробуйте убрать `--exact` или перейти к поиску по всем чатам.
* **Кодировка** — файлы пишутся в UTF‑8. Если TXT открывается кракозябрами, используйте редактор с поддержкой UTF‑8.

---

## Производительность

* Парсинг потоковый, но JSON все равно читается одной строкой в память. Если файл экстремально большой, запустите на машине с достаточным ОЗУ или разбейте экспорт на части средствами Telegram.

---

## Лицензия

Свободно используйте и модифицируйте под свои задачи. Если публично публикуете форк, оставьте ссылку на оригинал/автора в README.

---

## История изменений (кратко)

* v1: фильтр по `--user-id`/`--user`, выбор чата; устойчивый парсер; TXT/CSV вывод; режим обхода всех чатов с `*_ALL`.
